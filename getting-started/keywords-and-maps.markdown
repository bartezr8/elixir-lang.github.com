---
layout: getting-started
title: Коллекции
redirect_from: /getting-started/maps-and-dicts.html
---

# {{ page.title }}

{% include toc.html %}

До сих пор мы не обсуждали ассоциативные структуры данных, т.е структуры данных в которых можно связать нужное нам значение(я) с определенным ключом. В разных языках такие структуры называются по разному, например словари, хэши, ассоциативные массивы, и т.д.

В Elixir, есть две основные ассоциативные структуры данных: списки ключевых слов ( keyword lists ) и maps. Пришло время изучить их!

## Ключевые списки

Во многих функциональных языках, в качестве хранилища типа ключ-значение чаще всего используют список состоящий из 2 кортежей. В Elixir, для этого используется список кортежей и первым элементом кортежа (т.е ключом) является атом, такой список называют списком ключевых слов (keyword list):

```iex
iex> list = [{:a, 1}, {:b, 2}]
[a: 1, b: 2]
iex> list == [a: 1, b: 2]
true
```

Как видите в примере выше, в Elixir есть специальный синтаксис для объявления таких списков: `[key: value]`. Он формирует такой же список как и пример выше. Так как список ключевых слов это простой список, мы можем использовать по отношении к нему все операторы доступные для списков. Например, мы можем использовать оператор `++` для того что бы добавить новое значение в список ключевых слов ( keyword list ):

```iex
iex> list ++ [c: 3]
[a: 1, b: 2, c: 3]
iex> [a: 0] ++ list
[a: 0, a: 1, b: 2]
```

Обратите внимание что значение добавляется в начало списка, и при поиске будет получено в качестве первого совпавшего:

```iex
iex> new_list = [a: 0] ++ list
[a: 0, a: 1, b: 2]
iex> new_list[:a]
0
```

*Ключевые списки* являются важной частью языка, поскольку они обладают тремя основными характеристиками:

  * Ключ должен быть атомом.
  * Ключи распологаются, в том порядке в каком их задал разработчик.
  * Ключи могут буть использованны более одного раза.

Например, [библиотека Ecto](https://github.com/elixir-lang/ecto) использует эти особенности для реализации элегантного DSL который используется для написания запросов к базе данных:

```elixir
query = from w in Weather,
      where: w.prcp > 0,
      where: w.temp < 20,
     select: w
```

Поскольку ключевой список обладает подобными характеристиками, его часто используют для передачи параметров в функции. В 5 уроке, мы рассматривали работу макроса `if/2`, при этом мы упомянули что возможно использование синтаксиса:

```iex
iex> if false, do: :this, else: :that
:that
```

Пара `do:` и `else:` в данном случае является списком колючевых слов ( keyword lists )! По факту, пример выше является эквивалентом:

```iex
iex> if(false, [do: :this, else: :that])
:that
```
Который, как мы видели выше, анологичен:

```iex
iex> if(false, [{:do, :this}, {:else, :that}])
:that
```
В целом, когда список ключевых слов, является последним параметром в функции, квадратные скобки можно не использовать.

Не смотря на то что мы можем использовать *pattern match* вместе с *ключевыми списками*, это редко делается на практике, так как, использование *pattern matching* по отношению к списку требует соотвествия количества элементов и порядка их следования:

```iex
iex> [a: a] = [a: 1]
[a: 1]
iex> a
1
iex> [a: a] = [a: 1, b: 2]
** (MatchError) no match of right hand side value: [a: 1, b: 2]
iex> [b: b, a: a] = [a: 1, b: 2]
** (MatchError) no match of right hand side value: [a: 1, b: 2]
```

Для работы с *ключевыми списками*, в Elixir реализован [модуль `Keyword`](https://hexdocs.pm/elixir/Keyword.html). Запомните, хотя, *ключевой список* по факту является простым списком, и имеет те же линейные характеристики что и список. Это значит что чем длиннее список, тем больше требуется времени для поиска по ключу, подсчета количества элементов, и т.д. По этой причине, *keyword lists* используется в Elixir для работы с дополнительными параметрами. Если вам нужно хранить много элементов или обеспечивать связь *"один ключ, одно значение"*, вы должны использовать *maps*.

## Maps

Когда вам нужно хранилище ключ-значение, `maps` в Elixir являются структурой данных типа "go to". Создать `map` можно используя синтакс `%{}`:

```iex
iex> map = %{:a => 1, 2 => :b}
%{2 => :b, :a => 1}
iex> map[:a]
1
iex> map[2]
:b
iex> map[:c]
nil
```

Если мы сравним *maps* с *ключевым списком*, мы увидим два существеных отличия:

  * Maps в качестве ключа могут использовать любое значение.
  * Ключи в Maps не соблюдат порядок внесения, т.е нет гарантии что они буду распологатся в том порядке в каком вы их добавили.

В отличии от ключевого списка, maps отлично взаимодействуют с *pattern matching*. Когда map используются в шаблоне, они всегда равны подмножеству данного значения:

```iex
iex> %{} = %{:a => 1, 2 => :b}
%{2 => :b, :a => 1}
iex> %{:a => a} = %{:a => 1, 2 => :b}
%{2 => :b, :a => 1}
iex> a
1
iex> %{:c => c} = %{:a => 1, 2 => :b}
** (MatchError) no match of right hand side value: %{2 => :b, :a => 1}
```

Как показанно выше, присвоение соблюдается для тех элементов, для которых ключи совпадают с map соотвествует до тех пор пока совпадают ключи в передаваемом шаблоне . Therefore, an empty map matches all maps.

Переменные можно использовать для доступа к значениям, а так же в качестве ключей в :

```iex
iex> n = 1
1
iex> map = %{n => :one}
%{1 => :one}
iex> map[n]
:one
iex> %{^n => :one} = %{1 => :one, 2 => :two, 3 => :three}
%{1 => :one, 2 => :two, 3 => :three}
```

[Модуль `Map`](https://hexdocs.pm/elixir/Map.html) предоставляет API, схожее с API модуля `Keyword`, содержит набор полезных функций для работы с maps:

```iex
iex> Map.get(%{:a => 1, 2 => :b}, :a)
1
iex> Map.put(%{:a => 1, 2 => :b}, :c, 3)
%{2 => :b, :a => 1, :c => 3}
iex> Map.to_list(%{:a => 1, 2 => :b})
[{2, :b}, {:a, 1}]
```

В Maps для обновления значения ключа используется следующих синтаксис:

```iex
iex> map = %{:a => 1, 2 => :b}
%{2 => :b, :a => 1}

iex> %{map | 2 => "two"}
%{2 => "two", :a => 1}
iex> %{map | :c => 3}
** (KeyError) key :c not found in: %{2 => :b, :a => 1}
```

В примере выше ключ для которого указывается новое значение, должен существовать. Данный способ неможет быть использован для добавления нового колюча. Например, использование с ключом `:c` вызвало ошибку поскольку его нету в map.

Когда все ключи в `map` являются атомами, вы можете использовать *keyword* синтаксис для удобства:

```iex
iex> map = %{a: 1, b: 2}
%{a: 1, b: 2}
```

Другим интересным свойством maps является собственный синтаксис для доступа к ключам атома:

```iex
iex> map = %{:a => 1, 2 => :b}
%{2 => :b, :a => 1}

iex> map.a
1
iex> map.c
** (KeyError) key :c not found in: %{2 => :b, :a => 1}
```

Больншиство Elixir разработчиков предпочитают использовать синтаксис `map.field` и *pattern matching* вместо функций из модуля `Map` при работе с maps потому что они приводят к напористому стилю программирования. [В данной заметке](http://blog.plataformatec.com.br/2014/09/writing-assertive-code-with-elixir/) приведены при примеры как можно писать быстрее и эффективнее приложения на Elixir используя напористый стиль программированя.

> Примечание: Maps недавно были добавлены в Erlang <abbr title="Virtual Machine">VM</abbr> поэтому эффективная работа с более чем миллионом ключей возможна с версии Elixir v1.2. Поэтому, если вы работаете с версиями Elixir ниже 1.2  и вам нужна поддержка, по меньшей мере сотни ключей, вам следует использовать [модуль `HashDict`](https://hexdocs.pm/elixir/HashDict.html).

## Вложенные структуры данных

Зачастую у нас возникает необходимость в хранении maps внутри maps, или *keywords lists* внутри maps, и т.д. В Elixir есть удобный инструмент для работы с вложенными структурами данных, используя `put_in/2`, `update_in/2` и другие макросы, дающие схожий механизм работы как в императивных языках, при работе с неизменяемыми данными.

Представте что у вас есть такие данные:

```iex
iex> users = [
  john: %{name: "John", age: 27, languages: ["Erlang", "Ruby", "Elixir"]},
  mary: %{name: "Mary", age: 29, languages: ["Elixir", "F#", "Clojure"]}
]
[john: %{age: 27, languages: ["Erlang", "Ruby", "Elixir"], name: "John"},
 mary: %{age: 29, languages: ["Elixir", "F#", "Clojure"], name: "Mary"}]
```

У нас есть keyword list пользователей, где каждое значение это map хранящее имя, возраст и список предпочитаемых пользователем языков программирования. Если нам нужно получить возраст Джона, мы можм сделать это так:

```iex
iex> users[:john].age
27
```

Тот же синтаксис мы можем использовать для задания значения:

```iex
iex> users = put_in users[:john].age, 31
[john: %{age: 31, languages: ["Erlang", "Ruby", "Elixir"], name: "John"},
 mary: %{age: 29, languages: ["Elixir", "F#", "Clojure"], name: "Mary"}]
```

Макрос `update_in/2` работает похожим образом однако в качестве значения он принимает функцию которая определяет то как будет изменено значение. Для примера, удалим "Clojure" из списка языков у Мэри:

```iex
iex> users = update_in users[:mary].languages, fn languages -> List.delete(languages, "Clojure") end
[john: %{age: 31, languages: ["Erlang", "Ruby", "Elixir"], name: "John"},
 mary: %{age: 29, languages: ["Elixir", "F#"], name: "Mary"}]
```

Узнать больше об `put_in/2` и `update_in/2`, включая `get_and_update_in/2` который мозмоляет получать и изменять данные одновременно. Так же есть `put_in/3`, `update_in/3` и `get_and_update_in/3` которые предоставляют динамический доступ к данным. [Смотрите в соотвествующей документации модуля `Kernel`](https://hexdocs.pm/elixir/Kernel.html).

На этом мы завершаем рассмотрение ассоциативных структур данных в Elixir. Знаний об *keyword lists* и *maps*, вам будет достаточно для работы с ассоцитаивными данными в Elixir.
