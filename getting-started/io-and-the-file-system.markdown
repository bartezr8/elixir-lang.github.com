---
layout: getting-started
title: Операции ввода/вывода и работа с файловой системой
---

# {{ page.title }}

{% include toc.html %}

В этом уроке мы рассмотрим механизм ввода/вывода и работу с файловой системой, а также связанных с ними модулей, таких как [`IO`](https://hexdocs.pm/elixir/IO.html), [`File`](https://hexdocs.pm/elixir/File.html) и [`Path`](https://hexdocs.pm/elixir/Path.html).

Первоначально мы планировалли использовать данную главу в качестве ознокомительно по данному языку. Это было свзязано с тем что система ввода/вывода предоставляет оличную возможность по изучению философии Elixir и ознакомлению с Erlang <abbr title="Virtual Machine">VM</abbr>.

## Модуль `IO`

Модуль [`IO`](http://elixir-lang.org/docs/v1.0/elixir/IO.html) является основным механизмом в Elixir для чтения и записи данных из стандартного канала ввода/вывода (`:stdio`), стандартного канала вывода ошибок (`:stderr`), файлов, и других устройств IO. Модуль прост в использовании:

```iex
iex> IO.puts "hello world"
hello world
:ok
iex> IO.gets "yes or no? "
yes or no? yes
"yes\n"
```

По умолчанию, функции в модуле `IO` производят чтение с стандартного канала ввода и производят запись в стандартный канал вывода. Мы можем изменить это поведение, например, передадим атом `:stderr` в качестве аргумента (для записи в стандартный канал ошибок):

```iex
iex> IO.puts :stderr, "hello world"
hello world
:ok
```

## Модуль `File`

Модуль [`File`](https://hexdocs.pm/elixir/File.html) включает в себя функции которые позволяют открывать файлы как устройства IO. По умолчанию, файлы открываются в двоичном формате, это вынуждает разработчиков использовать специальные функции `IO.binread/2` и `IO.binwrite/2` из модуля `IO`:

```iex
iex> {:ok, file} = File.open "hello", [:write]
{:ok, #PID<0.47.0>}
iex> IO.binwrite file, "world"
:ok
iex> File.close file
:ok
iex> File.read "hello"
{:ok, "world"}
```

Файл может быть открыт в кодировке `:utf8`, данная настройка говорит модулю `File` при чтении интерпретировать байты из файла как байты в кодировке UTF-8.

По мимо функций отвечающих за открытие, чтение и запись файлов, модуль `File` содержит множество функций для работы с файловой системой. Эти функции имеют имена схожие с именами их UNIX аналогов. Например, функция `File.rm/1` используется для удаления файла, функция `File.mkdir/1` используется для создания папки, функция `File.mkdir_p/1` выполняет создание всех отсутствующих папок в указанном пути. Есть даже `File.cp_r/2` и `File.rm_rf/1` которые отвечают за рекурсивное копирование и удаление папок (включая копирование и удаление содержимого каталогов).

Как вы могли заметить функции в модуле `File` имеют два варианта: обычный и альтернативный с использование знака (`!`). Например, когда мы выполнялиw чтение из файла `"hello"` в примере выше, мы использовали функцию `File.read/1`. Вместо этого мы можем использовать `File.read!/1`:

```iex
iex> File.read "hello"
{:ok, "world"}
iex> File.read! "hello"
"world"
iex> File.read "unknown"
{:error, :enoent}
iex> File.read! "unknown"
** (File.Error) could not read file "unknown": no such file or directory
```

Обратите внимание что в данном варианте мы использовали знак `!` результатом выполнения функции в этом случае будет содержимое файла вместо кортежа, и если что то пойдет не так то функция вернет ошибку.

Использование функции без знака `!` предпочтительна когда вы хотите обработать результат используя *pattern matching*:

```elixir
case File.read(file) do
  {:ok, body}      -> # сделать что то с `body`
  {:error, reason} -> # обработать ошибку `reason`
end
```

Однако, если вам известно что будет передан файл, эффективнее будет использовать вызов без знака т.к в этом случает информация об ошибке будет более развернутой. Предотвратим запись:

```elixir
{:ok, body} = File.read(file)
```

в данном случае возникнет ошибка, функция `File.read/1` вернет `{:error, reason}` и *pattern matching* несработает. Вы все равно получите результат (в данном случае ошибку), но тело ошибки будет содержать сообщение о несовпадении с шаблоном (вводя тем самым в заблуждении, так причина ошибки не в этом).

Поэтому, если вам ненужно выполнять обработку ошибок предпочтительней будет использовать `File.read!/1`.

## Модуль `Path`

Большинство функций из модуля `File` в качестве аргумента ожидает путь. Чаще всего, в качестве пути выступает местоположение двоичного файла. Модуль [`Path`](https://hexdocs.pm/elixir/Path.html) предоставляет средства для работы с следующими путями:

```iex
iex> Path.join("foo", "bar")
"foo/bar"
iex> Path.expand("~/hello")
"/Users/jose/hello"
```

Использвание функции из модуля `Path` для работы с путями предпочтительней обычной манипуляции с строками, так как модуль `Path` сглаживает различия в формировании пути в  различных оперативных системах. И наконец, запомните что Elixir автоматически преобразует знак слэш (`/`) в обратный слэш (`\`) в Windows при работе с файлами.

Мы рассмотрели основные модули которые предоставляет Elixir для работы с IO и файловой системой. Далее мы рассмотрим некоторые особенности при работе с IO. Изучение данных разделов не обязательно, поэтому вы можете их пропустить, но они хорошо описывают работу IO в Erlang <abbr title="Virtual Machine">VM</abbr>.

## Процессы и управление группами

Вы могли заметить что функция `File.open/2` возвращает кортеж вида `{:ok, pid}`:

```iex
iex> {:ok, file} = File.open "hello", [:write]
{:ok, #PID<0.47.0>}
```

Это происходит потому что модуль `IO` работает с процессами (см [урок 11](/getting-started/processes.html)). Когда вы записываете данные используя функцию `IO.write(pid, binary)`, модуль `IO` отправляет сообщение процессу по идентификатору `pid` который выполняет обработку данной задачи. Давайте посмотрим что произойдет, если мы для обработки используем наш процесс:

```iex
iex> pid = spawn fn ->
...>  receive do: (msg -> IO.inspect msg)
...> end
#PID<0.57.0>
iex> IO.write(pid, "hello")
{:io_request, #PID<0.41.0>, #Reference<0.0.8.91>,
 {:put_chars, :unicode, "hello"}}
** (ErlangError) erlang error: :terminated
```

После выполнения функции `IO.write/2`, как мы можем увидеть запрос отправляется модулю `IO` который его обработает и выведет результат (кортеж из 4 элементов). В скоре после этого, мы увидим что он завершится неудачей, так как модуль `IO` ожидает результат выполнения, который мы ему не передаем.

Модуль [`StringIO`](https://hexdocs.pm/elixir/StringIO.html) обеспечивает отправку сообщений `IO`поверх строк:

```iex
iex> {:ok, pid} = StringIO.open("hello")
{:ok, #PID<0.43.0>}
iex> IO.read(pid, 2)
"he"
```

Путем моделирования IO устройств с процессами, Erlang <abbr title="Virtual Machine">VM</abbr> позволяет различным нодам обмениватся файловыми процессами между собой. Из всех IO устройств, существует один который является особым для каждого процесса: он осуществяет **управление группами**.

Когда вы пишите в `:stdio`, вы фактически отправляете сообщение лидеру группы, который записывает дескриптор файла стандартного вывода:

```iex
iex> IO.puts :stdio, "hello"
hello
:ok
iex> IO.puts Process.group_leader, "hello"
hello
:ok
```

Лидер группы может быть настроен для каждого процесса и используется в разных ситуациях. Например, при выполнении кода в удаленном терминале он гарантирует, что сообщения в удаленном узле перенаправляются и печатаются в терминале, который выполнил запрос.

## `iodata` и `chardata`

Во всех примера выше, мы использовали двоичные данные при работе с файлами. В уроке ["Двоичные данные, строки и списки символов"](/getting-started/binaries-strings-and-char-lists.html), Мы упоминали, как строки создаются из байтов, а списки символов - списки с кодовыми точками в кодировке Юникод.

Функции из модулей `IO` и `File` также могут принимать списки в качестве аргументов. Кроме того, они также позволяют использовать смешанный список состоящий из списков, целых чисел и двоичных данных:

```iex
iex> IO.puts 'hello world'
hello world
:ok
iex> IO.puts ['hello', ?\s, "world"]
hello world
:ok
```

Однако, использование списков при работе с вводом/выводом требует вниматлеьности. Список может представлять собой кучу байтов, а то какие из них будут использоватся зависит от кодировки используемой IO устройством. Если файл открывается без использования кодировки, файл будет обрабатыватся в *raw* режиме, для работы с такими данными предназначены функции начинающиеся `bin*` из модуля `IO`. Эти функции в качестве аргумента ожидают `iodata`; т.е., они ожидают список целых чисел, представляющих байты и двоичные файлы, которые дожны быть переданны.

С другой стороны, `:stdio` и файлы открытые с кодировкой `:utf8` работают с остальными функциями модуля `IO`. Эти функции ожидают в качестве аргумента `char_data`, то есть, список из символов или строк.

Хотя это различие и незначительно, вам нужно помнить об этом если вы собираетесь передавать в эти функции списки в качестве аргументов. Бинарики уже представлены базовыми байтами, поэтому они всегда считаются "raw".

На этом мы заканчиваем обзор IO устройств и связанного с ними функционала. Мы изучили четыре модуля - [`IO`](https://hexdocs.pm/elixir/IO.html), [`File`](https://hexdocs.pm/elixir/File.html), [`Path`](https://hexdocs.pm/elixir/Path.html) и [`StringIO`](https://hexdocs.pm/elixir/StringIO.html) - а также то как Erlang <abbr title="Virtual Machine">VM</abbr> использует процессы для работы с механизмом ввода/вывода, так же мы узнали как использовать  `chardata` и `iodata` при работе с операциями ввода/вывода.
