---
layout: getting-started
title: Бинарные данные, строки, символьные списки
---

# {{ page.title }}

{% include toc.html %}

В уроке "Типы", мы познакомились со строками и научились использовать функцию `is_binary/1` для проверки типа данных:

```iex
iex> string = "hello"
"hello"
iex> is_binary(string)
true
```

В данном уроке, мы будем изучать бинарные данные, то как они связанны с строками и чем в Elixir являются данные, в одинарных ковычках.

## UTF-8 и Unicode

Строки кодируются UTF-8 кодировкой. Для того что бы понять что это означает, нам нужно понять в чем разница между байтами и символьными кодами.

Стандарт Unicode свзявает знакомые нам символы алфавита с символьными кодами. Например, буква `a` имеет символьный код `97` а буква `ł` имеет код `322`. Для записи строки `"hełło"` на диск, нам нужно преобразовать символьные коды в байты. Если бы для кодирования одного символьного кода использовался один байт мы бы несмогли написать слово `"hełło"`, потому что для записи одного символа `ł` используется три символа `322`, при этом один байт может хранить только одно число от `0` до `255`. Но, конечно же, поскольку вы можете прочитать `"hełło"` на вашем экране, так как нам нужно это представить *как нибудь*. В этом нам может помочь кодировка.

Для преобразования символьных кодов в байты, нам нужно их как то закодировать. В Elixir используется кодировка UTF-8 по умолчанию. Когда мы говорим что строка представлена в кодировке UTF-8, мы имеем в виду что строка это набор байтов который содержит набор символьных кодов, указанных в кодировке UTF-8.

Так как у нас есть сиволы такие как `ł` имеющий символьный код `322`, нам нужно больше одно байта для кодирования таких символов. В этом и заключается разница в работе функций `byte_size/1` и `String.length/1`, рассмотрим пример:

```iex
iex> string = "hełło"
"hełło"
iex> byte_size(string)
7
iex> String.length(string)
5
```

Где, функция `byte_size/1` считает количество байтов, а функция `String.length/1` считает количество символов.

> Примечание: Если вы работаете в ос Windows, есть вероятность что ваша консоль не поддерживает UTF-8 по умолчанию. Вы можете указать кодировку для текущей сессии выполнив команду `chcp 65001` перед тем как запустить интерактивную оболочку `iex` (`iex.bat`).

Кодировка UTF-8 требует одного байта для кодировки символа `h`, `e`, и `o`, и два байта для кодирования символа `ł`. в Elixir, вы можете получить символ кода воспользовавшись оператором `?`:

```iex
iex> ?a
97
iex> ?ł
322
```

Так же вы можете использовать функцию из [модуля `String`](https://hexdocs.pm/elixir/String.html) для разбиения строки на отдельные символы, длина каждого из них равна 1:

```iex
iex> String.codepoints("hełło")
["h", "e", "ł", "ł", "o"]
```

Elixir имеет хорошую поддержку для работы со строками. Так же он поддерживает множество операций по работу с Юникод кодировкой. По факту, Elixir успешно проходит все тесты описанные в статье ["почему тип данных строка это плохо"](http://mortoray.com/2013/11/27/the-string-type-is-broken/).

Однако, строки это всего лишь одна сторона медали. Если строки это двоичные данные, мы можем использовать в работе функцию `is_binary/1`, Elixir должен иметь базовый тип расширяющий возможности строк. И он есть! Давайте поговорим о двоичных данных.

## Двоичные данные (и двоичные строки)

В Elixir, вы можете объявить двоичные данные используя оператор `<<>>`:

```iex
iex> <<0, 1, 2, 3>>
<<0, 1, 2, 3>>
iex> byte_size(<<0, 1, 2, 3>>)
4
```

Двоичные данные это последовательность байт. Эти байты могут идти в любой последовательности, даже если это сделает строку невалидной:

```iex
iex> String.valid?(<<239, 191, 191>>)
false
```

Операция по объеденению ( конкатенации ) строк по факту является операцией объеденения двоичных данных:

```iex
iex> <<0, 1>> <> <<2, 3>>
<<0, 1, 2, 3>>
```

Часто используемая фишка Elixir это конкатенация нулевого байта к строке `<<0>>` для того что бы увидеть её двоичное представление:

```iex
iex> "hełło" <> <<0>>
<<104, 101, 197, 130, 197, 130, 111, 0>>
```

Каждое число в двоичной строке является байтом находящимся в диапазоне от 0 до 255. Двоичные данные допускают испльзование модификаторов для хранения чисел больше чем 255 или преобразования символьного кода в его UTF-8 аналог:

```iex
iex> <<255>>
<<255>>
iex> <<256>> # truncated
<<0>>
iex> <<256 :: size(16)>> # use 16 bits (2 bytes) to store the number
<<1, 0>>
iex> <<256 :: utf8>> # the number is a code point
"Ā"
iex> <<256 :: utf8, 0>>
<<196, 128, 0>>
```

Если в байте 8 бит, что будет если указать в качестве размера 1 бит?

```iex
iex> <<1 :: size(1)>>
<<1::size(1)>>
iex> <<2 :: size(1)>> # truncated
<<0::size(1)>>
iex> is_binary(<<1 :: size(1)>>)
false
iex> is_bitstring(<<1 :: size(1)>>)
true
iex> bit_size(<< 1 :: size(1)>>)
1
```

Значение болше не является двоичным, но побитовая строка -- это последовательность бит! Таким образом двоичными данными является побитовая строка число битов в которой делится без остатка на 8.

```iex
iex>  is_binary(<<1 :: size(16)>>)
true
iex>  is_binary(<<1 :: size(15)>>)
false
```

Для проверки того является строка побитовой или двоичной мы можем использовать *pattern match*:

```iex
iex> <<0, 1, x>> = <<0, 1, 2>>
<<0, 1, 2>>
iex> x
2
iex> <<0, 1, x>> = <<0, 1, 2, 3>>
** (MatchError) no match of right hand side value: <<0, 1, 2, 3>>
```

Обратите внимание что для каждой записи в *binary pattern* ожидается точное соотвествие 8 битам. Если нам неизвестен размер строки мы можем воспользоваться *бинарным модификатором* в конце строки:

```iex
iex> <<0, 1, x :: binary>> = <<0, 1, 2, 3>>
<<0, 1, 2, 3>>
iex> x
<<2, 3>>
```

Аналогичный результат можно достигнуть воспользовавшись оператором `<>`:

```iex
iex> "he" <> rest = "hello"
"hello"
iex> rest
"llo"
```

Более полные сведения об использовании конструктора двоичных строки `<<>>` вы можете найти [в документации по Elixir](https://hexdocs.pm/elixir/Kernel.SpecialForms.html#%3C%3C%3E%3E/1). На этом завершается наш урок по битовым строкам, двоичным данным и строкам. Подводя итог можно сказать что строки кодируются в кодировку UTF-8, двоичную строку и в побитовую строку, при этом количество бит в ней должно делится без остатка на 8. Хотя это и показывает гибкость Elixir в работе с байтами и битами, 99% времени вы будете работать с двоичными данными, при этом чаще всего используются функции `is_binary/1` и `byte_size/1`.

## Список символов

Список символов это ничто иное как список символьных кодов. Список символов можно создать используя литерал строки в одинарных ковычках:

```iex
iex> 'hełło'
[104, 101, 322, 322, 111]
iex> is_list 'hełło'
true
iex> 'hello'
'hello'
iex> List.first('hello')
104
```

Как видите, вместо байт, в списке имволов используются символьные коды букв заключенных в одинарные ковычки ( по умолчанию IEx для вывода использует символьные коды, если какой то из символов выходит за пределы ASCII). Таким образом в то время как последовательность символов в двойных ковычках является строкой (т.е двоичными данными), символы в одинарных ковычках являются символным списком (т.е списком).

На практике, символьные списки чаще всего используются при взаимодействии с Erlang, так же стоит обратить внимание что старые библиотеки не принимают двоичные строки в качестве аргументов. Вы можете конвертировать символьные списки в строки и обратно используя функции `to_string/1` и `to_charlist/1`:

```iex
iex> to_charlist "hełło"
[104, 101, 322, 322, 111]
iex> to_string 'hełło'
"hełło"
iex> to_string :hello
"hello"
iex> to_string 1
"1"
```

Обратите внимание что данные функции являются полиморфными. Они не только конвертируют списки символов в строки, но также и числа в строки, атомы в строки и т.д.

Мы рассмотрели двоичные данные, строки и символьные строки, пришло время поговорить о данных типа ключ/значение.
