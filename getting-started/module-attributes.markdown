---
layout: getting-started
title: Атрибуты модулей
---

# {{ page.title }}

{% include toc.html %}

Атрибуты модулей в Elixir служат трем основным целям:

1. Они используются для описания модуля, которое впоследствии используется пользователем или виртуальной машиной.
2. Они работают как константы.
3. Они работают как временное хранилище, которое будет использоватся в процессе компиляции.

Давайте поочередно проверим каждое утверждение.

## Как описание

Elixir позаимствовал концепцию модулей из Erlang. Например:

```elixir
defmodule MyServer do
  @vsn 2
end
```

В примере выше, мы сохраняем версию модуля в аттрибуте. Аттрибут `@vsn` использует механизм перезагрузки кода в Erlang <abbr title="Virtual Machine">VM</abbr> для отслеживания изменений в модуле. В качестве версии устанавливается контрольная сумма MD5 для функций модуля.

В Elixir есть несколько зарезервированных аттрибутов. Наиболее часто используемыми являются:

* `@moduledoc` - предоставляет документацию для текущего модуля.
* `@doc` - предоставляет документацию для функции или макроса, следующего за атрибутом.
* `@behaviour` - (Обратите внимание на британскую орфографию), используется для определения <abbr title = "Открытая платформа Telecom> OTP </ abbr> или пользовательского поведения.
* `@before_compile` - предоставляет хук который будет вызван после того как модуль скомпилируется. Позволяет инжектить функции точно перед компиляцией.

`@moduledoc` и `@doc` являются наиболее часто используемыми аттрибутами, и мы надеемся что вы будете их часто использовать. Подробнее об этом в статье [написание документации в Elixir](https://hexdocs.pm/elixir/writing-documentation.html).

Давайте вернемся к модулю `Math` который мы объявили в предыдущей главе, добавим к нему описание и сохраним его в файл `math.ex`:

```elixir
defmodule Math do
  @moduledoc """
  Provides math-related functions.

  ## Examples

      iex> Math.sum(1, 2)
      3

  """

  @doc """
  Calculates the sum of two numbers.
  """
  def sum(a, b), do: a + b
end
```

В Elixir можно использовать разметку Markdown совместно с heredocs для написания удобочитаемой документации. Heredocs это формат поддерживающий многострочные комментарии, он начинается и заканчиватся тремя обратными кавычками, сохраняя форматирование текста внутри себя. Мы можем получить документацию по любому скомпилированному модулю напрямую из IEx:

```bash
$ elixirc math.ex
$ iex
```

```iex
iex> h Math # Access the docs for the module Math
...
iex> h Math.sum # Access the docs for the sum function
...
```

Так же для создания документации можно воспользоватся инструментом под названием [ExDoc](https://github.com/elixir-lang/ex_doc) который предназначен для генерации HTML страниц на основе аттрибутов документации.

С полным списком поддерживаемых атриботов вы можете ознакомится на странице документаци [Модуля](https://hexdocs.pm/elixir/Module.html). Так же Elixir использует аттрибуты для объявления [typespecs](/getting-started/typespecs-and-behaviours.html).

В этом разделе описаны встроенные атрибуты. Однако атрибуты могут также использоваться разработчиками или  библиотеками.

## Как константа

Elixir разработчики могут использовать аттрибуты модуля как константы:

```elixir
defmodule MyServer do
  @initial_state %{host: "147.0.0.1", port: 3456}
  IO.inspect @initial_state
end
```

> Примичание: в отличии от Erlang, аттрибуты заданные пользователем не сохраняются в модуле по умолчанию. Они существуют только во время компиляции. Разработчик может настроить атрибут так, что бы его поведение было похоже на поведение в Erlang используя функцию [`Module.register_attribute/3`](https://hexdocs.pm/elixir/Module.html#register_attribute/3).

Попытка обращения к необъявленному атрибуту, приведет к возникновению ошибки:

```elixir
defmodule MyServer do
  @unknown
end
warning: undefined module attribute @unknown, please remove access to @unknown or explicitly set it before access
```

И наконец, значение аттрибута можно прочитать внутри функции:

```elixir
defmodule MyServer do
  @my_data 14
  def first_data, do: @my_data
  @my_data 13
  def second_data, do: @my_data
end

MyServer.first_data #=> 14
MyServer.second_data #=> 13
```

Каждый раз, когда атрибут считывается внутри функции, берется моментальный снимок его текущего значения. Другими словами, значение считывается во время компиляции, а не во время выполнения. Как мы увидим, это также делает атрибуты полезными для использования в качестве хранилища во время компиляции модуля.

## Как временное хранилище

Один из проектов написанных на Elixir известный как [`Plug`](https://github.com/elixir-lang/plug), который предназначен для использования в качестве базы для написания библиотек и фреймворков на Elixir.

Библиотека Plug позволяет разработчикам собственные plugs, которые могут быть запущены в веб сервере:

```elixir
defmodule MyPlug do
  use Plug.Builder

  plug :set_header
  plug :send_ok

  def set_header(conn, _opts) do
    put_resp_header(conn, "x-header", "set")
  end

  def send_ok(conn, _opts) do
    send(conn, 200, "ok")
  end
end

IO.puts "Running MyPlug with Cowboy on http://localhost:4000"
Plug.Adapters.Cowboy.http MyPlug, []
```

В примере выше, мы использовали макрос `plug/1` для подключения функции которая будет вызыватся при каждом запросе на сервер. Каждый раз когда вы вызываете `plug/1`, библиотека Plug сохраняет переданный аргумент в аттрибуте `@plugs`. Перед тем как модуль будет скомпилирован, Plug выполнит функцию обратного вызова, которая была объявлена функцией (`call/2`) во время обработки HTTP запроса. Эта функция запустит все plugs внутри `@plugs` по порядку.

Для того что бы понять основы, нам нужны макросы, поэтому мы вернемся к этому примеру в уроке по мета-программированию. Однако основное внимание нужно уделить тому, как использование аттрибутов в качестве хранилища позволяет разработчикам создавать DSLs.

В качестве другого примера может служить [фреймворк ExUnit](https://hexdocs.pm/ex_unit/) который использует аттрибуты модуля в качестве анотации и хранилища:

```elixir
defmodule MyTest do
  use ExUnit.Case

  @tag :external
  test "contacts external service" do
    # ...
  end
end
```

Теги в ExUnit используются для описания тестов. Теги впоследствии могут использованны для сортировки тестов. Например, вы можете избежать запуска внешних тестов на своей машине, потому что они медленные и зависят от других сервисов, в то время как они все еще доступны в вашем приложении.

В следующем уроке мы рассмотрим структуры и протоколы, перед тем как перейти к обработке ошибок и другим конструкциям языка, таким как sigils и comprehensions.
