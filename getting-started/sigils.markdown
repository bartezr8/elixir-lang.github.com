---
layout: getting-started
title: Sigils
---

# {{ page.title }}

{% include toc.html %}

Мы знаем что в Elixir, символы в двойных ковычках являются строкой, а в одинарных ковычках списком символов. Однако, это касается только структур данных которые можно представить в виде последовательности символов. К примеру атомы задаются с помощью команды `:atom`.

One of Elixir's goals is extensibility: developers should be able to extend the language to fit any particular domain. Computer science has become such a wide field that it is impossible for a language to tackle many fields as part of its core. Rather, our best bet is to make the language extensible, so developers, companies, and communities can extend the language to their relevant domains.

В данном уроке, мы будем изучать *sigils*, которые являются одним из механизмов  provided by the language for working with textual representations. Sigils start with the tilde (`~`) character which is followed by a letter (which identifies the sigil) and then a delimiter; optionally, modifiers can be added after the final delimiter.

## Регулярные выражения

Часто используемый sigil в Elixir это `~r`, который используется для создания [регулярных выражений](https://en.wikipedia.org/wiki/Regular_Expressions):

```iex
# Данному регулярному выражению соотвествуют строки содержащие "foo" или "bar":
iex> regex = ~r/foo|bar/
~r/foo|bar/
iex> "foo" =~ regex
true
iex> "bat" =~ regex
false
```

В Elixir используются Perl-совместимые регулярные выражения (regexes), описаные в библиотеке [PCRE](http://www.pcre.org/). В регулярных выражениях доступно использование модификаторов. Например, модификатор `i` делает регулярное выражение регистро независиммым:

```iex
iex> "HELLO" =~ ~r/hello/
false
iex> "HELLO" =~ ~r/hello/i
true
```

См [ документацию по `Regex`](https://hexdocs.pm/elixir/Regex.html) для получения более полной информации по модификторам и опциям которые можно использовать в регулярных выражениях.

До сих пор, во всех примерах мы использовали `/` для обрамления регулярных выражений. Однако sigils поддерживает 8 различных разделителей:

```
~r/hello/
~r|hello|
~r"hello"
~r'hello'
~r(hello)
~r[hello]
~r{hello}
~r<hello>
```

Различные разделители используются для написания литеральных выражений без использования экранирующих разделителей. В качестве примера рассмотрим, регулярное выражение с использованием обратных слэшей `~r(^https?://)` выглядит намного лучше чем `~r/^https?:\/\/`. Точно так же, если в регулярном выражении используются обратные слэши и оператор захвата (см. `()`), вместо скобок двойные ковычки вместо скобок.

## Строки, списки символов, и списки слов с sigils

Помимо регулярных выражений, в Elixir существуют добавочные символы.

### Строки

Sigil `~s` можно использовать для создания строк вместо двойных ковычек. Sigil `~s` используется в том случае когда в строке встречаются двойные ковычки:

```iex
iex> ~s(this is a string with "double" quotes, not 'single' ones)
"this is a string with \"double\" quotes, not 'single' ones"
```

### Списки символов

Sigil `~c` испльзуется когда нужно создать список символов в котором встречаются одинарные ковычки:

```iex
iex> ~c(this is a char list containing 'single quotes')
'this is a char list containing \'single quotes\''
```

### Списки слов

Sigil `~w` используется для создания списка слов. Внутри сигила `~w`, слова разделаются пробелами.

```iex
iex> ~w(foo bar bat)
["foo", "bar", "bat"]
```

Sigil `~w` так же принимает модификаторы `c`, `s` и `a`  (так же можно использовать с символьными списками, строками и атомами), которые определяют какого типа будут данные возвращаемые в качестве результата:

```iex
iex> ~w(foo bar bat)a
[:foo, :bar, :bat]
```

## Интерполяция и экранирующие символы в sigils

Кроме sigils в нижнем регистре, в Elixir поддерживаются sigils в верхнем регистре для совместного использования с экранирующими символами и механизмом интерполяцией. Независимо от того испльзуем мы `~s` или `~S` результатом будет строка, в первом случае в строке можно использовать экранирующие символы и механизм интерполяции в последнем случае нет:

```iex
iex> ~s(String with escape codes \x26 #{"inter" <> "polation"})
"String with escape codes & interpolation"
iex> ~S(String without escape codes \x26 without #{interpolation})
"String without escape codes \\x26 without \#{interpolation}"
```

В строках и символьных списках можно использовать следующие экранирующие символы:

* `\\` - один обратный слэш
* `\a` - bell/alert
* `\b` - возврат на символ назад
* `\d` - delete
* `\e` - escape
* `\f` - перевод карретки к началу страницы
* `\n` - новая строка
* `\r` - возврат карретки
* `\s` - пробел
* `\t` - символ табуляции
* `\v` - вертикальная табуляция
* `\0` - нулевой байт
* `\xDD` - один байт в шестнадцатеричной системе исчисления (прим `\x13`)
* `\uDDDD` и `\u{D...}` - символ юникода codepoint в шестнадцатеричной системе исчисления (прим `\u{1F600}`)

В дополнение к выше сказанному, двойные ковычки внутри строки в двойных ковычках нужно предварять обратным слэшем `\"`, и по аналогии делать тоже самое для одинарных ковычек `\'`. Тем неменее, лучшем решением в данной ситуации будет использование разделителей вместо экранирующих символов.

Sigils так же поддерживает использование heredocs синтаксиса, т.е изпользование 3 двойных или одинарных ковычек в качестве разделителя:

```iex
iex> ~s"""
...> this is
...> a heredoc string
...> """
```

Чаще всего *heredoc sigils* используется для оформления документации. Постоянное использование экранирующих символов при написании рано или поздно приведет к ошибке, так как в большинстве случаев может потребоваться использование двойных экранирующих символов подряд:

```elixir
@doc """
Преобразуем двойные ковычки в одинарные.

## Пример

    iex> convert("\\\"foo\\\"")
    "'foo'"

"""
def convert(...)
```

Используя `~S`, эту проблему можно полностью избежать:

```elixir
@doc ~S"""
Преобразуем двойные ковычки в одинарные.

## Пример

    iex> convert("\"foo\"")
    "'foo'"

"""
def convert(...)
```

## Пользовательские sigils

Как говорилось в начале урока, sigils в Elixir являются расширяемыми. По факту, используя sigil `~r/foo/i` эквивалентно использованию `sigil_r` с двоичными данными и символьными списками в качестве аргументов:

```iex
iex> sigil_r(<<"foo">>, 'i')
~r"foo"i
```

Вы можете получить подробную информацию по `~r` sigil используя команду `sigil_r`:

```iex
iex> h sigil_r
...
```

Вы можете создать свой собственный sigils используя функцию `sigil_{identifier}` в качестве шаблона. Для примера, создадим `~i` sigil который возвращает целое число (комбинируя с `n` результат будет инвертирован):

```iex
iex> defmodule MySigils do
...>   def sigil_i(string, []), do: String.to_integer(string)
...>   def sigil_i(string, [?n]), do: -String.to_integer(string)
...> end
iex> import MySigils
iex> ~i(13)
13
iex> ~i(42)n
-42
```

Sigils так же могут быть использованы для выполнения работы с макросами во время компиляции. Например, регулярные выражения в Elixir компилируются в эффективные конструкции во время компиляции в исходный код, что позволяет их опускать их во время рантайми. Если вас интересует данная тема, мы рекомендуем изучить то как реализованны макросы и sigils реализованны в модуле `Kernel` (где объявлена функция `sigil_*`).
