---
layout: getting-started
title: Использование alias, require, и import
---

# {{ page.title }}

{% include toc.html %}

Для реализации модульности в Elixir используются операторы `alias`, `require` и `import`, `use`.

```elixir
# Использование псевдонима для модуля позволяет вызывать функцию используя имя Bar вместо Foo.Bar
alias Foo.Bar, as: Bar

# Убеждаемся что модуль скомпилирован и доступен ( как правило для макросов )
require Foo

# Импортируем функции из модуля Foo таким образом мы сможем использовать их без префикса `Foo.`
import Foo

# Выполняет пользовательский код объявленый в модуле Foo как исполняемый
use Foo
```

Давайте более подробно рассмотрим работу с ними. Имейте в виду, первые три оператора являются директивами, потому что они имеют **лексическую область видимости**, в то время как `use` общая точка вызова.

## alias

`alias` позволяют указать псевдоним для любого модуля.

Представте что модуль использует специальную реализацию функции `Math.List`. Использование оператора `alias`  позволит нам ссылатся на функцию `Math.List` по имени `List` не указывая при этом имя модуля:

```elixir
defmodule Stats do
  alias Math.List, as: List
  # В конечном модуле функция List использовать Math.List.
end
```

Оригинальная функция `List` остается доступной в модуле `Stats` по её полному имени `Elixir.List`.

> Примечание: Все модули доступные в Elixir объявлены в пространстве имен `Elixir`. Тем не менее, для удобства использования, указание "Elixir." не требуется.

Псевдонимы часто используются для сокращения. По факту, использование `alias` без опции `:as` указывает в качестве псевдонима последний элемент в имени модуля, например:

```elixir
alias Math.List
```

Тоже самое что и:

```elixir
alias Math.List, as: List
```

Обратите внимание что оператор `alias` имеет **лексическую область видимости**, что позволяет использовать псевдонимы в составе определенных функций:

```elixir
defmodule Math do
  def plus(a, b) do
    alias Math.List
    # ...
  end

  def minus(a, b) do
    # ...
  end
end
```

В примере выше, мы используем оператор `alias` внутри функции `plus/2`, при этом псевдоним будет доступен только внутри функции `plus/2`. В функции `minus/2` он будет недоступен.

## require

В Elixir доступны макросы для реализации механизма мета программирования ( написания кода который генерирует код).

Макросы это части кода, которые выполняются и расширяются во время компиляции. Это означает, что для того, чтобы использовать макрос, нам необходимо, гарантировать что его модуль в котором он описан будет доступен во время компиляции. Это делается с помощью оператора `require`:

```iex
iex> Integer.is_odd(3)
** (UndefinedFunctionError) function Integer.is_odd/1 is undefined or private. However there is a macro with the same name and arity. Be sure to require Integer if you intend to invoke this macro
iex> require Integer
Integer
iex> Integer.is_odd(3)
true
```

В Elixir, `Integer.is_odd/1` объявлен как макрос. Это значит что, для того что бы использовать `Integer.is_odd/1`, нам сначала нужно подключить модуль `Integer`.

В большинстве случаем не требуется подключение модулей перед их использованием, за исключением тех случаев когда мы хотим что бы макрос был доступен в нашем модуле. Попытка использования макроса который небыл подключен вызовет ошибку. Так же как и оператор `alias`, оператор `require` имеет лексическую область видимости. В последующих уроках мы подробнее рассмотрим макросы.

## import

Оператор `import` используется когда нам нужнен доступ к функции или макросу из другого модуля без использования обращения к нему по его молному имени. Для примера, если мы хотим использовать только функцию `duplicate/2` из модуля `List`, мы можем импортировать только её:

```iex
iex> import List, only: [duplicate: 2]
List
iex> duplicate :ok, 3
[:ok, :ok, :ok]
```

В данном случае, мы импортировали толко функцию `duplicate` из модуля `List`. Использование опции `:only` опционально, такой способ рекомендуется во избежание импорта всех функций в пространство имен. Так же доступна опция `:except` для импорта всех фукций за исключением некоторых.

Оператор `import` для опции `:only` доступны `:macros` и `:functions`. Например, для импорта только макросов, мы можем использовать:

```elixir
import Integer, only: :macros
```

Или для импорта только функций:

```elixir
import Integer, only: :functions
```

Оператор `import` так же имеет **лексическую область видимости**. Это значит что мы можем импортировать определенные функции и макросы в конкретную функцию:

```elixir
defmodule Math do
  def some_function do
    import List, only: [duplicate: 2]
    duplicate(:ok, 10)
  end
end
```

В примере выше, мы импортировали функцию `List.duplicate/2` в конкретной функции и доступна она будет только в ней. Это значит что функция `duplicate/2` небудет доступна в другой функции в этом модуле (или в другом модуле).

Обратите внимание что `import` - вание модуля автоматически его подключит ( неявно выполнив `require`).

## use

Хотя `use` и не является дерективой, он тесно связан с `require` что позволяет использовать модуль в текущем контексте. Макрос `use` часто используется для добавление дополнительного функциона в текущий контекст, как правило используется в модулях.

Для примера, для написания тестов с использованием фреймворка ExUnit, разработчику нужно подключить модуль `ExUnit.Case`:

```elixir
defmodule AssertionTest do
  use ExUnit.Case, async: true

  test "always pass" do
    assert true
  end
end
```

Неявным образом оператор `use` подключает указанный модуль и затем вызывает `__using__/1` функция обратного вызова, позволяет сделать доступным код подключаемого модуля в текущем контексте. Проще говоря, модуль:

```elixir
defmodule Example do
  use Feature, option: :value
end
```

будет скомпилирован в:

```elixir
defmodule Example do
  require Feature
  Feature.__using__(option: :value)
end
```

## Введение в псевдонимы

На данный момент  скорее всего вы задаетесь вопросом: чем именно являются псевдонимы в Elixir и как они реализованны?

Псевдоним в Elixir является идентификатором который начинается с большой буквы (например как `String`, `Keyword` и т.д) который преобразуется в атом при компиляции. Например, псевдоним `String` по умолчанию преобразуется в атом `:"Elixir.String"`:

```iex
iex> is_atom(String)
true
iex> to_string(String)
"Elixir.String"
iex> :"Elixir.String" == String
true
```

Используя директиву `alias/2`, мы можем изменить структуру в которую будет преобразован атом.

Псевдонимы преобразуются в атом потому что в Erlang <abbr title="Virtual Machine">VM</abbr> (и следовательно в Elixir) модули всегда представлены атомами. Например, вот такой механизм мы бы использовали для вызова Erlang модулей:

```iex
iex> :lists.flatten([1, [2], 3])
[1, 2, 3]
```

## Вложенные модули

Теперь после того как мы разобрались с псевдонимами, мы можем поговорить о вложенных модулях и том как это работает в Elixir. Рассмотрим следующий пример:

```elixir
defmodule Foo do
  defmodule Bar do
  end
end
```

В примере мы объявили 2 модуля: `Foo` и `Foo.Bar`. Доступ к модулю `Bar` мы можем получить через `Foo` поскольку они находятся в одной лексической области видимости. Код приведенный выше тоже самое что и:

```elixir
defmodule Elixir.Foo do
  defmodule Elixir.Foo.Bar do
  end
  alias Elixir.Foo.Bar, as: Bar
end
```

Если, позднее, модуль `Bar` будет вынесен за приделы модуля `Foo`, он будет доступен по его полному имени (`Foo.Bar`) или для него нужно будет укзать псевдоним с помощью дерективы `alias`.

**Примечание**: В Elixir, нельзя объявить модуль `Foo` до того как он будет доступен как `Foo.Bar`, так как язык преобразует все имена модулей в атомы. Вы можете определить произвольно вложенные модули без определения каких-либо модулей в цепи (например, `Foo.Bar.Baz` без объявления ` Foo` или `Foo.Bar`).

Как вы увидите в последствии, псевдонимы играют важную роль в использовании макросов, как гарант их чистоты.

## Подключение нескольких модулей одновременно ( alias/import/require/use )

Начиная с Elixir v1.2, it is possible to alias, import or require multiple modules at once. This is particularly useful once we start nesting modules, which is very common when building Elixir applications. Для примера, представте что у вас есть приложение в котором все модули вложены в `MyApp`, вы можете создать псевдонимы для модулей `MyApp.Foo`, `MyApp.Bar` и `MyApp.Baz` одной строкой:

```elixir
alias MyApp.{Foo, Bar, Baz}
```

На этом мы заканчиваем обзор модулей в Elixir.