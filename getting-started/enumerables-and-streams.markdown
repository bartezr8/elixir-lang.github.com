---
layout: getting-started
title: Перечисляемые данные и потоки
---

# {{ page.title }}

{% include toc.html %}

## Enumerables

В Elixir реализованна концепция перечисляемых данных и [модуль `Enum`](https://hexdocs.pm/elixir/Enum.html) для работы с ними. В уроках ранее мы рассматривали 2 типа перечисляемых данных: списки и maps.

```iex
iex> Enum.map([1, 2, 3], fn x -> x * 2 end)
[2, 4, 6]
iex> Enum.map(%{1 => 2, 3 => 4}, fn {k, v} -> k * v end)
[2, 12]
```

Модуль `Enum` предоставляет большой набор функций для преобразования, сортировки, группировки, фильтрации и извлечения элементов из перечисляемых данных. Это один из наиболее часто используемых модулей в Elixir.

Так же в Elixir реализованны диапазоны:

```iex
iex> Enum.map(1..3, fn x -> x * 2 end)
[2, 4, 6]
iex> Enum.reduce(1..3, 0, &+/2)
6
```

Все функции в модуле Enum предназначены для работы с перечисляемыми данными. Для других операций, таких как вставка и объеденение отдельных элементов, вам нужно будет подключить отдельные модули для работы с этими типами данных. Например, если вам необходимо вставить элемент на определенную позицию в списке, вы можете воспользоваться функцией `List.insert_at/3` из [модуля `List`](https://hexdocs.pm/elixir/List.html).

Мы выяснили что функции из модуля `Enum` являются полиморфными так как они могут работать с различными типами данных. На практике, функции из модуля `Enum` могут работать с любыми типами данных описаных в [протоколе `Enumerable`](https://hexdocs.pm/elixir/Enumerable.html). Мы поговорим о *протоколах* в следующих уроках; Теперь давайте поговорим о подвиде перечисляемых данных именуемых *потоками*.

## Немедленные vs Отложенные

Все функции в модуле `Enum` являются немедленными. Большая часть функций в качестве входных значений принимают перечисляемые данные и возвращают в качестве результата список:

```iex
iex> odd? = &(rem(&1, 2) != 0)
#Function<6.80484245/1 in :erl_eval.expr/5>
iex> Enum.filter(1..3, odd?)
[1, 3]
```

Это означает что при выполнении нескольких операций с `Enum`, каждая функция будет генерировать промежуточный список до тех пор пока мы не получим результат:

```iex
iex> 1..100_000 |> Enum.map(&(&1 * 3)) |> Enum.filter(odd?) |> Enum.sum
7500000000
```

В примере выше функции объеденены в цепочку. Мы начинаем с диапозона затем, каждый элемент умножаем на 3. Эта операция вернет список состоящий из `100_000` элементов. Затем мы фильтруем список сохраняя все нечетные элементы в новый список, теперь у нас есть список с `50_000` элементов, на завершающем этапе мы суммируем эти элементы.

## Оператор pipe

Символ `|>` используемый выше называется **pipe оператор**: он принимает результат выражения с левой стороны и передает его в качестве первого аргумента функции с правой стороны. Данный оператор анологичен Unix оператору `|`. Целью данного оператора является получение данных и передача их дальше по цепочке. Код выше можно переписать не используя оператор `|>`:

```iex
iex> Enum.sum(Enum.filter(Enum.map(1..100_000, &(&1 * 3)), odd?))
7500000000
```

Дополнительную информацию по оператору *pipe* [вы можете получить из документации](https://hexdocs.pm/elixir/Kernel.html#%7C%3E/2).

## Потоки

В качестве альтернативы `Enum`, в Elixir есть [модуль `Stream`](https://hexdocs.pm/elixir/Stream.html) который предназначен для отложеных операций ( ленивых ):

```iex
iex> 1..100_000 |> Stream.map(&(&1 * 3)) |> Stream.filter(odd?) |> Enum.sum
7500000000
```

Потоки являются *ленивыми*, и их можно компоновать с перечисляемыми данными.

В приведенном выше примере , `1..100_000 |> Stream.map(&(&1 * 3))` в качестве результата будет возвращен поток, в котором выполняется операция `map` выполняющая вычисления в диапазоне `1..100_000`:

```iex
iex> 1..100_000 |> Stream.map(&(&1 * 3))
#Stream<[enum: 1..100000, funs: [#Function<34.16982430/1 in Stream.map/2>]]>
```

Кроме того мы можем компоновать множество *Stream* операций используя оператор *pipe*:

```iex
iex> 1..100_000 |> Stream.map(&(&1 * 3)) |> Stream.filter(odd?)
#Stream<[enum: 1..100000, funs: [...]]>
```

Всместо создания врменных списков, потоки позволяют построить работу программу таким образом что вычисления выполняются после возвращения контекста исполнения в основной поток. Потоки полезны когда нужно обработать большой массив данных, *возможно бесконечных* коллекций.

Большинство функций из модуля `Stream` в качестве значений могут принимать перечисляемые структуры в качестве воходных значений и возвращать в качестве результата потоки. Так же в нем доступны функции для создания потоков. Например, функция `Stream.cycle/1` используется для создания потока в ктором бесконечно перебираются значения переданных перечисляемых данных. Будте осторожны эта функция не является альтернативой функции `Enum.map/2` в анологичном потоке, поскольку цикл в ней может выполнятся бесконечно:

```iex
iex> stream = Stream.cycle([1, 2, 3])
#Function<15.16982430/2 in Stream.cycle/1>
iex> Enum.take(stream, 10)
[1, 2, 3, 1, 2, 3, 1, 2, 3, 1]
```

С другой стороны, у нас есть функция `Stream.unfold/2` которая используется для генерации значений из получаемых данных:

```iex
iex> stream = Stream.unfold("hełło", &String.next_codepoint/1)
#Function<39.75994740/2 in Stream.unfold/2>
iex> Enum.take(stream, 3)
["h", "e", "ł"]
```

Другая интересная нам функция это `Stream.resource/3` которая используется в качестве обертки над ресурсами, она гарантирует что они открыты непосредственно перед перечислением и закрыты после этого, даже в случае неудачи. Например, мы можем использовать его для передачи файла в потоке:

```iex
iex> stream = File.stream!("path/to/file")
#Function<18.16982430/2 in Stream.resource/3>
iex> Enum.take(stream, 10)
```

В данном примере мы получаем первые 10 строк из указанного файла. Как вы уже наверно поняли потоки незаменимы при работе с большими файлами или медленными сетевыми операциями.

По началу будет сложно определится функционал какого модуля [`Enum`](https://hexdocs.pm/elixir/Enum.html) или [`Stream`](https://hexdocs.pm/elixir/Stream.html) использовать в конкретном случае. В дальнейших уроках мы сосреготочимся на работе с модулем `Enum`, так же для операция требующих отложеных вычислений мы будем использовать модуль `Stream`.

Далее мы рассмотрим основной функционал Elixir, Процессы, которые используются для написания многопоточных, распределеных программ в простой форме.
