---
layout: getting-started
title: Типы данных в Elixir
---

# Типы данных

{% include toc.html %}

В данной главе мы изучим основные типы данных в Elixir: Целые числа ( integer ), Числа с плавающей точкой ( float ), Булевы значения ( boolean ), атомы ( atom ), строки ( string ), списки ( lists ) и кортежи ( tuple ):

```iex
iex> 1          # integer
iex> 0x1F       # integer
iex> 1.0        # float
iex> true       # boolean
iex> :atom      # atom / symbol
iex> "elixir"   # string
iex> [1, 2, 3]  # list
iex> {1, 2, 3}  # tuple
```

## Арифмитические операции

Запустим интерактивную оболочку `iex` и введем следующие примеры:

```iex
iex> 1 + 2
3
iex> 5 * 5
25
iex> 10 / 2
5.0
```

Обратите внимание что деление `10 / 2` вернет число с плавающей точкой `5.0` вместо ожидаемого целого числа `5`. В Elixir, оператор `/` в качестве результата всегда возвращает число с плавающей точкой. Если вам нужно выполнить деление целых чисел с получением остатка или без остатка, используйте функции `div` и `rem`:

```iex
iex> div(10, 2)
5
iex> div 10, 2
5
iex> rem 10, 3
1
```

Обратите внимание что при использовании функций Elixir позволяет опускать скобки, таким образом делая код более читабельным и элегантным.

Elixir поддерживает краткую запись двоичных, восьмеричных, и шестнадцатеричных чисел:

```iex
iex> 0b1010
10
iex> 0o777
511
iex> 0x1F
31
```

Для записи данных числел необходимо обязательно указывать точку после первого числа, так же поддерживается экспонента `e`:

```iex
iex> 1.0
1.0
iex> 1.0e-10
1.0e-10
```

В Elixir числа с плавающей точкой являются 64 битными с двойной точностью.

Для округления числа с плавающей точкой до целого числа используется функция `round`, для получения целой части от числа с плавающей точкой используется функция `trunc`.

```iex
iex> round(3.58)
4
iex> trunc(3.58)
3
```

## Функции

В Elixir для задания функции указывается имя и арность ( прим. `round\2` ). Арность указывает количество аргумментов принимаемых функцией. Для описания функций в документации используется имя и арность. Например запись `round/1` обозначает что это функция `round()` которая принимает один аргумент, в качестве еще одно примера рассмотрим запись `round/2` здесь имеется в виду функция `round()` которая принимат два аргумента.

## Булевы значения

Elixir поддерживает булевы значения `true` и `false`:

```iex
iex> true
true
iex> true == false
false
```

В Elixir реализован набор функций для проверки типов данных. Например, функция `is_boolean/1` может быть использована для проверки является ли переданное значение булевым типом данных или нет:

```iex
iex> is_boolean(true)
true
iex> is_boolean(1)
false
```

Для проверки типа числа мы можем использовать `is_integer/1`, `is_float/1` или `is_number/1`, для случаев когда значением является целое число или число с плавающей точкой.

> Примечание: Для получения справки по используемой функции можно воспользоваться функцией `h()` для получения справки по её применению. Функция `h` может быть использована для получения информации по любой функции. Для примера, в консоле введем `h is_integer/1` в качестве результата в консоль будет выведенно `is_integer/1`. Данная функция так же может быть использована для операторов и конструкторов ( можете попробовать `h ==/2`).

## Атомы

Атомы это константы, значением которых является их имя. В некоторых языках амтомами называют символы:

```iex
iex> :hello
:hello
iex> :hello == :world
false
```

По факту булевы значения `true` и `false` являются атомами:

```iex
iex> true == :true
true
iex> is_atom(false)
true
iex> is_boolean(:false)
true
```

## Строки

Строками в Elixir называются значения обрамленные двойными ковычками, хранятся в кодировке UTF-8:

```iex
iex> "hellö"
"hellö"
```

> Примечание: если вы работаете в ос Windows, скорее всего консоль по умолчанию не поддерживает кодировку UTF-8 по умолчанию. Вы можете изменить кодировку для текущей сессии, для этого нужно выполнить в консоле команду `chcp 65001` перед запуском интерактивной оболочки IEx.

В Elixir так же реализованна интерполяция строк:

```iex
iex> "hellö #{:world}"
"hellö world"
```

Внутри строк возможно использовать управляющие символы, например символ перевода строки:

```iex
iex> "hello
...> world"
"hello\nworld"
iex> "hello\nworld"
"hello\nworld"
```

Вы можете вывести строку в консоль с помощью функции `IO.puts/1` из модуля `IO`:

```iex
iex> IO.puts "hello\nworld"
hello
world
:ok
```

В качестве результата выполнения функция `IO.puts/1` вернет атом `:ok`.

В Elixir строки являются двоичными данными представленные в качестве последовательности байтов:

```iex
iex> is_binary("hellö")
true
```

Так же мы можем получить длинну байтов используемых для строки:

```iex
iex> byte_size("hellö")
6
```

Обратите внимание что мы плучили длинну строки в байтах равную 6, хотя по факту у нас используется 5 символов. Так получилось из за того что для кодирования символа "ö" в кодировке UTF-8 нужно 2 байта. Получить длинну строки в символах мы можем воспользовавшись функцией `String.length/1`:

```iex
iex> String.length("hellö")
5
```

Библиотека для работу со [строками](https://hexdocs.pm/elixir/String.html) содержит набор функций которые работают со строками так как это описано в стандарте Unicode:

```iex
iex> String.upcase("hellö")
"HELLÖ"
```

## Анонимные функции

Анонимные функции начинаются с ключевого слова `fn` и звершаются ключевым словом `end`:

```iex
iex> add = fn a, b -> a + b end
#Function<12.71889879/2 in :erl_eval.expr/5>
iex> add.(1, 2)
3
iex> is_function(add)
true
iex> is_function(add, 2) # проверка является ли add функцией, если да то принимает ли она 2 аргумента?
true
iex> is_function(add, 1) # проверка является ли add функцией, если да то принимает ли она 1 аргумент?
false
```

В Elixir функции являются функциями высшего порядка, это значит что они могут принимать в качестве агрумента функцию, так же как например строку или число. В примере выше, в качестве агрумента для функции `is_function/1` мы передавали значение `add`, в этом случае в качестве результата будет возвращено `true`. Так же мы можем проверить количество принимаемых аргументов функцией передав её в функцию `is_function/2`.

Для вызова анонимной функции используется точка (`.`) между переменной и скобками. Применение точки необходимо для избежания двусмысленного толкования переменной `add` и функции `add/2`. В этом плане Elixir проводит четкое рзграничение между именноваными и анонимными функциями. Более продробно это будет рассмотрено в [8 Уроке](/getting-started/modules-and-functions.html).

Анонимные функции использующиеся для создания замыкания имеют доступ к переменным объявленным в теле функции. Для примера объявим функцию которая будет будет содержать вызов ранее объявленной анонимной фунуции `add`:

```iex
iex> double = fn a -> add.(a, a) end
#Function<6.71889879/1 in :erl_eval.expr/5>
iex> double.(2)
4
```

*Запомните:* переменные объявленные в теле функции не влияют на переменные с тем же именем за приделами функции в которой они объявлены:

```iex
iex> x = 42
42
iex> (fn -> x = 0 end).()
0
iex> x
42
```

## Списки

В Elixir квадратные скобки используются для объявления списка значений. Значения могут быть любого типа:

```iex
iex> [1, 2, true, 3]
[1, 2, true, 3]
iex> length [1, 2, 3]
3
```

Два списка можно сложить или вычесть используя операторы `++/2` and `--/2`:

```iex
iex> [1, 2, 3] ++ [4, 5, 6]
[1, 2, 3, 4, 5, 6]
iex> [1, true, 2, false, 3, true] -- [true, false]
[1, 2, 3, true]
```

На протяжении наших уроков мы будем много говорить о хвосте и голове списка. У каждого списка есть *голова* и *хвост*. Головой списка является первый элемент, хвостом является остальная часть списка. Для получения головы списка используется функция `hd/1` для получения хвоста `tl/1`. Для примера присвоим список переменной и получим его голову и хвост:

```iex
iex> list = [1, 2, 3]
iex> hd(list)
1
iex> tl(list)
[2, 3]
```

Попытка получить хвост или голову у пустого списка вызовет ошибку:

```iex
iex> hd []
** (ArgumentError) argument error
```

Иногда при создании списка в качестве результата он возвращает значение в одинарных ковычках. Например:

```iex
iex> [11, 12, 13]
'\v\f\r'
iex> [104, 101, 108, 108, 111]
'hello'
```

Когда Elixir встречает список потенциальных ASCII чисел, Elixir выводит на экран список символов (литерал списка символов). Символьные списки часто встречаютсся при работе с кодом Erlang. Если вы  встречаете при выводе незнакомое значение и вы не уверены в том что знаете что это такое, вы можете получить по нему подробную информацию с помощь функции `i/1`:

```iex
iex> i 'hello'
Term
  'hello'
Data type
  List
Description
  ...
Raw representation
  [104, 101, 108, 108, 111]
Reference modules
  List
```

Хочу обратить ваше внимание, на то что, одно и тоже значение, в одинарных и двойных ковычках при сравнении не равны друг другу:

```iex
iex> 'hello' == "hello"
false
```

Значение в одинарных ковычках является символьным списком, а в двойных ковычках строкой. Мы поговорим об этом подробнее в уроке по ["бинарным данным, строкам и символьным спскам"](/getting-started/binaries-strings-and-char-lists.html).

## Кортежи

Для объявления кортежей в Elixir используются фигурные скобки. Так же как и списки, кортежи могут содержать любые значения:

```iex
iex> {:ok, "hello"}
{:ok, "hello"}
iex> tuple_size {:ok, "hello"}
2
```

Кортежи хранят элементы смежно в памяти. Это позволяет ускорить доступ к элементу кортежа, а также быстро рассчитать его размер. Индексы начинаются с нуля:

```iex
iex> tuple = {:ok, "hello"}
{:ok, "hello"}
iex> elem(tuple, 1)
"hello"
iex> tuple_size(tuple)
2
```

Мы так же можем положить элемент в конкретную ячейку кортежа используя её индекс, для этого можно воспользоваться функцией `put_elem/3`:

```iex
iex> tuple = {:ok, "hello"}
{:ok, "hello"}
iex> put_elem(tuple, 1, "world")
{:ok, "world"}
iex> tuple
{:ok, "hello"}
```

Обратите что функция `put_elem/3` в качестве результата вернет новый кортеж. Учтите что первоначальный кортеж небудет изменен, потому что данные в Elixir являются иммутабельными. Благодаря иммутабельности, писать код в Elixir проще по той причине что вам ненужно беспокоится о том что кто то изменит данные в время работы программы.

## Списки или кортежи?

В чем различие между списками и кортежами?

Списки хранятся в памяти в виде связанных списков, а это означает, что каждый элемент в списке имеет свое значение и указывает на следующий элемент до тех пор пока небудет достигнут конец списка. Мы называем каждую пару значения и указатель на **cons cell** :

```iex
iex> list = [1 | [2 | [3 | []]]]
[1, 2, 3]
```

Это означает, что доступ к длине списка является линейной операцией: мы должны пройти весь список, чтобы вычислить его размер. Обновление списка быстро до тех пор, пока значения предопределенны:

```iex
iex> [0 | list]
[0, 1, 2, 3]
```

С другой стороны Кортежи сохраняются в памяти непрерывно. Это позволяет быстро получить размер кортежа или доступ к элементу по индексу. Тем не менее, обновление или добавление элементов в кортеж является дорогостоющей операцией, поскольку она требует, копирования всего кортежа.

Учитывая разницу в скорости следует пнимательно подходить к их использованию. Чаще всего кортежи используют для структурирования результатов работы функции. Например функция `File.read/1` используется для чтения содержимого файла. Результатом выполнения функции будет кортеж:

```iex
iex> File.read("path/to/existing/file")
{:ok, "... contents ..."}
iex> File.read("path/to/unknown/file")
{:error, :enoent}
```

Если по пути переданному в качестве аргумента в функцию `File.read/1` существует файл, в качестве результата функция вернет кортеж у которого в качестве первого аргумента будет атом `:ok`, а в качестве второго аргумента содержимое файла. В противном случае, результатом будет кортеж у которого первым аргументом будет атом `:error` и вторым аргументом сообщение об ошибке.

Большую часть времени, Elixir учит писать правильный код хотя бывают и исключения. К примеру для получения значения по индексу есть функция `elem/2`, но для списков анологичных функций нет:

```iex
iex> tuple = {:ok, "hello"}
{:ok, "hello"}
iex> elem(tuple, 1)
"hello"
```

При вычислении размера структуры данных, Elixir придерживается простого правила: если необходимо переодически получать размер структуры используется функция `size`  ( если размер структуры статичен ), функция `length` если операция линейная (т.е. при росте размера скорость работы функции замедляется).

Например, у нас есть 4 функции для вычисления длины структуры: `byte_size/1` (для вычисления количества байтов в строке), `tuple_size/1` (для вычисления размера кортежа), `length/1` (для вычисления длины строки) и `String.length/1` (для вычисления количества графем в строке). Мы используем `byte_size` для вычисления количества байт в строке -- является "дешевой" операцией. Для вычисления количетва символов юникода, используется функция `String.length` которая работает намного медленее так как для получение длины обходит всю строку.

В Elixir доступны типы данных `Port`, `Reference`, и `PID` (как правило используется при взаимодействии с процессами), в последствии мы рассмотрим работу с процессами.
